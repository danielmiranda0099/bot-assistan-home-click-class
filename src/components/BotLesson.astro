---
// BotLesson.astro
import TextInput from "./TextInput.astro";
import LessonControls from "./LessonControls.astro";
import ProgressBar from "./ProgressBar.astro";
import SpeechToText from "./SpeechToText.astro";
import SummaryModal from "./SummaryModal.astro";
---

<div id="bot-lesson" class="bot-lesson">
  <ProgressBar current={0} total={0} />
  <div class="chat-container">
    <button id="iniciar-btn" class="iniciar-btn pulse">Iniciar</button>
    <div id="chat-messages" class="chat-messages">
      <!-- Messages will be added here -->
    </div>
  </div>
  <SpeechToText />
  <TextInput />
  <LessonControls />
  <SummaryModal />
</div>

<script>
  import { BotState } from "../types/index.ts";
  import { BotStateMachine } from "../stores/StateMachine.ts";
  import { ActivityStore } from "../stores/ActivityStore.ts";
  import { ChatStore } from "../stores/ChatStore.ts";
  import {
    OpenAIService,
    type OpenAIFeedback,
  } from "../stores/OpenAIService.ts";
  import type { Activity, Message, QuestionFeedbackData } from "../types/index.ts";
  // import activityData from "../activities/a2.json";
  import activityData from "../activities/a1.json";
  // import activityData from "../activities/example-activity-no-hints.json";
  import { marked } from "marked";
  import { AudioService } from "../stores/AudioService.ts";

  const OPENAI_API_KEY = import.meta.env.PUBLIC_OPENAI_API_KEY;
  const OPENAI_ASSISTANT_ID = import.meta.env.PUBLIC_OPENAI_ASSISTANT_ID;
  const OPENAI_GENERAL_FEEDBACK_ASSISTANT_ID = import.meta.env.PUBLIC_OPENAI_GENERAL_FEEDBACK_ASSISTANT_ID;

  // Initialize stores and state machine
  const stateMachine = new BotStateMachine();
  const activityStore = new ActivityStore();
  const chatStore = new ChatStore();
  const openAIService = new OpenAIService(OPENAI_API_KEY, OPENAI_ASSISTANT_ID);
  const openAIGeneralFeedbackService = new OpenAIService(OPENAI_API_KEY, OPENAI_GENERAL_FEEDBACK_ASSISTANT_ID);
  const audioService = new AudioService();
  let lessonEnded = false;
  let hintUsedForCurrentQuestion = false;
  let waitingMessageId: string | null = null;
  let questionStartTime: number | null = null;

  function isLastQuestion(): boolean {
    const totalQuestions = activityStore.currentActivity?.questions.length || 0;
    return activityStore.currentQuestionIndex === totalQuestions - 1;
  }

  // Load activity
  console.log("Loading activity:", activityData);
  activityStore.loadActivity(activityData as Activity);

  document.addEventListener("DOMContentLoaded", () => {
    const iniciarBtn = document.getElementById("iniciar-btn");
    if (iniciarBtn) {
      iniciarBtn.addEventListener("click", startLesson);
    }

    const sendButton = document.querySelector(".text-input-container button");
    if (sendButton) {
      sendButton.addEventListener("click", handleUserInput);
    }

    const clearButton = document.getElementById("clear-button");
    if (clearButton) {
      clearButton.addEventListener("click", handleClearInput);
    }

    const resetButton = document.querySelector(
      ".lesson-controls button:first-child"
    );
    if (resetButton) {
      resetButton.addEventListener("click", resetLesson);
    }

    const hintButton = document.querySelector(
      ".lesson-controls button:nth-child(3)"
    );
    if (hintButton) {
      hintButton.addEventListener("click", showHint);
    }

    const summaryButton = document.getElementById("summary-button");
    if (summaryButton) {
      summaryButton.addEventListener("click", handleShowSummary);
    }

    // NUEVO: Agregar listener para Try Again
    const tryAgainButton = document.querySelector(
      ".lesson-controls button:nth-child(2)"
    );
    if (tryAgainButton) {
      tryAgainButton.addEventListener("click", handleTryAgain);
    }

    // NUEVO: Agregar listeners para navegaci√≥n
    document.addEventListener("navigation-back", handleBackNavigation);
    document.addEventListener("navigation-next", handleNextNavigation);

    updateUI();
  });

  function startLesson() {
    audioService.play('click');

    // Detect and clear corrupted localStorage data where counters are null or duplicates exist
    if (activityStore.currentActivity) {
      const activityId = activityStore.currentActivity.id;
      const key = `activity-feedback-${activityId}`;
      const stored = localStorage.getItem(key);
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          let reason = '';
          if (parsed.correct === null || parsed.partial === null || parsed.incorrect === null || parsed.answeredQuestions === null) {
            reason += 'null counters; ';
          }
          const questionIds = parsed.questionsFeedback?.map((f: any) => f.questionId) || [];
          const uniqueIds = new Set(questionIds);
          if (questionIds.length !== uniqueIds.size) {
            reason += 'duplicates in questionsFeedback; ';
          }
          if (reason) {
            localStorage.removeItem(key);
            console.log(`Cleared corrupted feedback data for activity ${activityId}: ${reason.trim()}`);
          }
        } catch (error) {
          localStorage.removeItem(key);
          console.log('Cleared invalid feedback data for activity:', activityId);
        }
      }
    }

    // Hide the iniciar button before starting
    const iniciarBtn = document.getElementById(
      "iniciar-btn"
    ) as HTMLButtonElement;
    if (iniciarBtn) {
      iniciarBtn.style.display = "none";
    }

    // NUEVO: Inicializar storage para esta actividad
    if (activityStore.currentActivity) {
      chatStore.initializeStorage(activityStore.currentActivity.id);
    }

    // NUEVO: Establecer primera pregunta en ChatStore
    const firstQuestion = activityStore.getCurrentQuestion();
    if (firstQuestion) {
      chatStore.setCurrentQuestion(firstQuestion.id);
    }

    stateMachine.transition(BotState.READY_CHECK);
    const greeting = getRandomGreeting();
    const greetingMessage = addMessage("greeting", greeting);
    updateUI();
    setTimeout(() => {
      chatStore.removeMessage(greetingMessage.id);
      renderMessages();
      stateMachine.transition(BotState.ASK);
      askQuestion();
      updateUI();
    }, 3000);
    debugFeedbackAccumulator();
  }

  function resetLesson() {
    console.log("üîÑ RESETTING LESSON");

    // Play click sound
    audioService.play("click");

    // === 1. LIMPIAR STORAGE COMPLETAMENTE ===
    chatStore.clearAllStorage();
    console.log("‚úì localStorage cleared");

    // === 2. LIMPIAR TODOS LOS CHATS (incluyendo Map interna) ===
    chatStore.questionChats.clear(); // NUEVO: limpiar el Map interno
    chatStore.clearMessages();
    renderMessages();
    console.log("‚úì All chats cleared");

    // === 3. RESETEAR ACTIVITY STORE ===
    activityStore.currentQuestionIndex = 0;
    activityStore.userResponses = [];
    activityStore.answeredQuestions.clear();
    console.log("‚úì Activity store reset");

    // === 3.5. CLEAR FEEDBACK FROM STORAGE AND REINITIALIZE ACCUMULATOR ===
    activityStore.clearFeedbackFromStorage();
    if (activityStore.currentActivity) {
      activityStore.feedbackAccumulator = {
        activityId: activityStore.currentActivity.id,
        activityTitle: activityStore.currentActivity.title,
        activityLevel: activityStore.currentActivity.level,
        activityContext: activityStore.currentActivity.activityContext,
        activityDescription: activityStore.currentActivity.description,
        questionsFeedback: [],
        totalQuestions: activityStore.currentActivity.questions.length,
        answeredQuestions: 0,
        correct: 0,
        partial: 0,
        incorrect: 0,
      };
    }
    console.log("‚úì Feedback cleared and accumulator reinitialized");

    // === 4. RESETEAR FLAGS LOCALES ===
    lessonEnded = false;
    hintUsedForCurrentQuestion = false;
    waitingMessageId = null;
    questionStartTime = null;
    console.log("‚úì Local flags reset");

    // === 5. RESETEAR STATE MACHINE ===
    stateMachine.currentState = BotState.INIT;
    console.log("‚úì State machine reset to INIT");

    // === 6. REINICIALIZAR STORAGE ===
    if (activityStore.currentActivity) {
      chatStore.initializeStorage(activityStore.currentActivity.id);
      console.log("‚úì Storage reinitialized");
    }

    // === 7. ESTABLECER PRIMERA PREGUNTA ===
    const firstQuestion = activityStore.getCurrentQuestion();
    if (firstQuestion) {
      chatStore.setCurrentQuestion(firstQuestion.id);
      console.log(`‚úì Set current question to: ${firstQuestion.id}`);
    }

    // === 8. INICIAR LECCI√ìN FRESCA (sin cargar estado anterior) ===
    stateMachine.transition(BotState.READY_CHECK);
    const greeting = getRandomGreeting();
    addMessage("greeting", greeting);

    stateMachine.transition(BotState.ASK);

    // CAMBIO CR√çTICO: No llamar askQuestion() que intenta cargar estado
    // En su lugar, mostrar la pregunta directamente
    if (firstQuestion) {
      addMessage("assistant", firstQuestion.question);
      questionStartTime = Date.now();
    }

    // === 9. ACTUALIZAR UI ===
    updateUI();

    console.log("üîÑ LESSON RESET COMPLETE");
  }
  // DEPRECATED: Skip functionality removed
  // function skipQuestion() { ... }

  function showHint() {
    // Play click sound
    audioService.play("click");

    // Guard: solo permitir hint en estado ASK
    if (!canPerformAction("show hint", [BotState.ASK])) {
      return;
    }

    const question = activityStore.getCurrentQuestion();
    if (question && question.hint) {
      addMessage("hint", question.hint);
      hintUsedForCurrentQuestion = true;
      updateUI();
    }
  }

  function handleShowSummary() {
    console.log("=== handleShowSummary: Show Summary clicked ===");
    console.log("Current state machine state:", stateMachine.currentState);
    console.log("Lesson ended flag:", lessonEnded);
    console.log("Current question index:", activityStore.currentQuestionIndex);
    console.log("Total questions:", activityStore.currentActivity?.questions.length || 0);

    // Play click sound
    audioService.play("click");

    // Guard: solo permitir en FEEDBACK cuando es la √∫ltima pregunta
    if (!canPerformAction("show summary", [BotState.FEEDBACK])) {
      console.warn("‚ùå Cannot show summary: Invalid state. Current state:", stateMachine.currentState, "Allowed states: [BotState.FEEDBACK]");
      return;
    }
    console.log("‚úÖ State validation passed");

    const isLast = isLastQuestion();
    console.log("Is last question:", isLast);
    if (!isLast) {
      console.warn("‚ùå Cannot show summary: Not on last question. Current index:", activityStore.currentQuestionIndex, "Total questions:", activityStore.currentActivity?.questions.length || 0);
      return;
    }
    console.log("‚úÖ Last question validation passed");

    const currentQuestion = activityStore.getCurrentQuestion();
    console.log("Current question:", currentQuestion ? { id: currentQuestion.id, question: currentQuestion.question.substring(0, 50) + "..." } : "null");

    if (!currentQuestion) {
      console.warn("‚ùå Cannot show summary: No current question available");
      return;
    }

    const isAnswered = activityStore.isQuestionAnswered(currentQuestion.id);
    console.log("Is current question answered:", isAnswered);

    if (!isAnswered) {
      console.warn("‚ùå Cannot show summary: Last question not answered. Question ID:", currentQuestion.id);
      return;
    }
    console.log("‚úÖ Question answered validation passed");

    // Validation: ensure accumulator exists and activity is complete
    const accumulator = activityStore.getFeedbackAccumulator();
    console.log("Feedback accumulator exists:", !!accumulator);
    if (accumulator) {
      console.log("Accumulator details:", {
        activityId: accumulator.activityId,
        totalQuestions: accumulator.totalQuestions,
        answeredQuestions: accumulator.answeredQuestions,
        correct: accumulator.correct,
        partial: accumulator.partial,
        incorrect: accumulator.incorrect,
        questionsFeedbackCount: accumulator.questionsFeedback.length
      });
    }

    if (!accumulator) {
      console.warn("‚ùå Cannot show summary: No feedback accumulator available");
      return;
    }
    console.log("‚úÖ Accumulator existence validation passed");

    const isComplete = activityStore.isActivityComplete();
    console.log("Is activity complete:", isComplete);
    if (!isComplete) {
      console.warn("‚ùå Cannot show summary: Activity not complete. Answered questions:", accumulator.answeredQuestions, "Total questions:", accumulator.totalQuestions);
      return;
    }
    console.log("‚úÖ Activity completion validation passed");

    // Check if modal function exists
    const openModalFunction = (window as any).openSummaryModal;
    console.log("openSummaryModal function exists on window:", !!openModalFunction);
    if (!openModalFunction) {
      console.warn("‚ùå Cannot show summary: openSummaryModal function not found on window");
      return;
    }
    console.log("‚úÖ Modal function availability validation passed");

    // Check if modal element exists
    const modalElement = document.getElementById("summary-modal");
    console.log("Summary modal element exists in DOM:", !!modalElement);
    if (!modalElement) {
      console.warn("‚ùå Cannot show summary: Summary modal element not found in DOM");
      return;
    }
    console.log("‚úÖ Modal element existence validation passed");

    // Attempt to open the modal
    try {
      console.log("üîÑ Attempting to open summary modal...");
      openModalFunction();
      console.log("‚úÖ Summary modal opened successfully");
    } catch (error) {
      console.error("‚ùå Error opening summary modal:", error);
    }
  }

  function askQuestion() {
    const question = activityStore.getCurrentQuestion();
    if (question) {
      // NUEVO: Verificar si hay estado guardado
      const savedState = chatStore.loadQuestionFromStorage(question.id);

      if (savedState && savedState.completed) {
        // Si hay estado guardado y est√° completada, restaurar todo
        console.log("Restoring saved question state");
        loadQuestionState(question.id);
      } else {
        // Si no hay estado o no est√° completada, mostrar pregunta fresca
        addMessage("assistant", question.question);
        hintUsedForCurrentQuestion = false;
        questionStartTime = Date.now();
      }
    }
  }

  function addMessage(type: Message["type"], content: string): Message {
    const chatContainer = document.querySelector(".chat-container");
    const shouldScroll = chatContainer
      ? chatContainer.scrollTop + chatContainer.clientHeight >=
        chatContainer.scrollHeight - 50
      : true;

    const message: Message = {
      id: `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // ID √∫nico
      type,
      content,
      timestamp: new Date(),
    };
    chatStore.addMessage(message);
    renderMessages();

    // Play message sound for assistant, hint, and feedback types
    if (type === "assistant" || type === "hint" || type === "feedback") {
      audioService.play("message");
    }

    // Solo hacer scroll si el usuario estaba cerca del final (dentro de 50px)
    if (shouldScroll) {
      scrollToBottom();
    }

    return message;
  }

  function renderMessages() {
    try {
      const messagesContainer = document.getElementById("chat-messages");
      if (!messagesContainer) {
        console.warn("Messages container not found");
        return;
      }

      // Collect existing message IDs before clearing
      const existingMessageIds = new Set<string>();
      const existingBubbles = messagesContainer.querySelectorAll('[data-message-id]');
      existingBubbles.forEach(bubble => {
        const id = bubble.getAttribute('data-message-id');
        if (id) {
          existingMessageIds.add(id);
        }
      });

      messagesContainer.innerHTML = "";
      chatStore.getMessages().forEach((message) => {
        const bubble = document.createElement("div");
        const isChat = message.type === "assistant" || message.type === "user";

        // Check if message was already rendered
        const wasAlreadyRendered = existingMessageIds.has(message.id);
        bubble.className = `message-bubble ${isChat ? "message-chat" : ""} message-${message.type}${wasAlreadyRendered ? " animated" : ""}`;
        bubble.setAttribute("data-message-id", message.id);

        const content = document.createElement("div");
        content.className = "content";

        if (message.type === "feedback") {
          content.innerHTML = message.content;
        } else {
          content.textContent = message.content;
        }

        bubble.appendChild(content);
        messagesContainer.appendChild(bubble);
      });

      // Auto-scroll
      const chatContainer = messagesContainer.parentElement;
      if (chatContainer) {
        setTimeout(() => {
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }, 0);
      }
    } catch (error) {
      console.error("Error rendering messages:", error);
    }
  }

  function scrollToBottom() {
    const chatContainer = document.querySelector(".chat-container");
    if (chatContainer) {
      // Usar requestAnimationFrame para mejor timing
      requestAnimationFrame(() => {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      });
    }
  }

  const greetings = [
    "Hello! Let's start the lesson.",
    "Hi there! Ready to learn?",
    "Welcome! Let's begin.",
  ];

  function getRandomGreeting() {
    return greetings[Math.floor(Math.random() * greetings.length)];
  }

  function canPerformAction(
    action: string,
    allowedStates: BotState[]
  ): boolean {
    const isAllowed = allowedStates.includes(stateMachine.currentState);

    if (!isAllowed) {
      console.warn(
        `‚ö†Ô∏è Cannot perform "${action}" in state ${stateMachine.currentState}. ` +
          `Allowed states: ${allowedStates.join(", ")}`
      );
    }

    return isAllowed;
  }

  function notifySpeechButtonState() {
    const isAskState = stateMachine.currentState === BotState.ASK;
    if ((window as any).updateSpeechButtonState) {
      (window as any).updateSpeechButtonState(isAskState);
    }
  }

  function updateUI() {
    console.log("=== updateUI called ===");
    console.log("State:", stateMachine.currentState);
    console.log("Question index:", activityStore.currentQuestionIndex);
    console.log("Lesson ended:", lessonEnded);

    const isEvaluating = stateMachine.currentState === BotState.EVALUATE;

    const currentQuestion = activityStore.getCurrentQuestion();
    const isQuestionAnswered = currentQuestion
      ? activityStore.isQuestionAnswered(currentQuestion.id)
      : false;

    console.log("Current question:", currentQuestion?.id);
    console.log("Is answered:", isQuestionAnswered);

    // === CONTROLES DE INPUT ===
    const input = document.querySelector(
      ".text-input-container textarea"
    ) as HTMLTextAreaElement;
    const sendBtn = document.querySelector(
      ".text-input-container button"
    ) as HTMLButtonElement;
    const clearBtn = document.getElementById(
      "clear-button"
    ) as HTMLButtonElement;

    const inputDisabled =
      stateMachine.currentState === BotState.INIT ||
      stateMachine.currentState === BotState.READY_CHECK ||
      stateMachine.currentState === BotState.FEEDBACK ||
      lessonEnded ||
      isEvaluating;

    if (input) input.disabled = inputDisabled;
    if (sendBtn) sendBtn.disabled = inputDisabled;
    if (clearBtn) clearBtn.disabled = inputDisabled;

    // === BOT√ìN RESET ===
    const resetBtn = document.querySelector(
      ".lesson-controls button:first-child"
    ) as HTMLButtonElement;
    if (resetBtn) {
      resetBtn.disabled = stateMachine.currentState === BotState.INIT || isEvaluating;
    }

    // === BOT√ìN TRY AGAIN ===
    const tryAgainBtn = document.querySelector(
      ".lesson-controls button:nth-child(2)"
    ) as HTMLButtonElement;
    if (tryAgainBtn) {
      // Try Again se habilita solo en ASK o FEEDBACK (cuando hay algo que reintentar)
      const tryAgainEnabled =
        (stateMachine.currentState === BotState.ASK ||
          stateMachine.currentState === BotState.FEEDBACK) &&
        !lessonEnded &&
        !isEvaluating;

      tryAgainBtn.disabled = !tryAgainEnabled;
    }

    // === BOT√ìN HINT ===
    const hintBtn = document.querySelector(
      ".lesson-controls button:nth-child(3)"
    ) as HTMLButtonElement;
    const hasHint = currentQuestion ? !!currentQuestion.hint : false;

    if (hintBtn) {
      const hintDisabled =
        stateMachine.currentState !== BotState.ASK ||
        !hasHint ||
        hintUsedForCurrentQuestion ||
        lessonEnded ||
        isEvaluating;

      hintBtn.disabled = hintDisabled;
    }

    // === BOT√ìN SPEECH TO TEXT ===
    const speechButton = document.getElementById(
      "speech-button"
    ) as HTMLButtonElement;
    if (speechButton) {
      speechButton.disabled = inputDisabled;
    }

    // === NAVEGACI√ìN BACK/NEXT ===
    const canGoBack = activityStore.currentQuestionIndex > 0 && !lessonEnded && !isEvaluating;
    const canGoNext =
      isQuestionAnswered &&
      stateMachine.currentState === BotState.FEEDBACK &&
      !lessonEnded &&
      !isLastQuestion() &&
      !isEvaluating;

    console.log("Can go back:", canGoBack);
    console.log("Can go next:", canGoNext);

    // Llamar funci√≥n global del ProgressBar
    if ((window as any).updateNavigationButtons) {
      (window as any).updateNavigationButtons(canGoBack, canGoNext);
    }

    // === BOT√ìN SEE SUMMARY ===
    const summaryButton = document.getElementById(
      "summary-button"
    ) as HTMLButtonElement;
    if (summaryButton) {
      const enableSummary =
        isLastQuestion() &&
        isQuestionAnswered &&
        stateMachine.currentState === BotState.FEEDBACK &&
        !isEvaluating;
      summaryButton.disabled = !enableSummary;
    }

    // === PROGRESS BAR ===
    updateProgressBar();

    notifySpeechButtonState();

    console.log("=== updateUI complete ===");
  }

  function updateProgressBar() {
    const current =
      stateMachine.currentState === BotState.INIT
        ? 0
        : activityStore.currentQuestionIndex + 1;
    const total = activityStore.currentActivity
      ? activityStore.currentActivity.questions.length
      : 0;
    const textEl = document.querySelector(".progress-text");
    const fillEl = document.querySelector(".progress-fill");
    if (textEl) textEl.textContent = `Question ${current} of ${total}`;
    if (fillEl)
      (fillEl as HTMLElement).style.width =
        `${total > 0 ? (current / total) * 100 : 0}%`;
  }

  function debugFeedbackAccumulator() {
    const accumulator = activityStore.getFeedbackAccumulator();
    console.log("=== FEEDBACK ACCUMULATOR DEBUG ===");
    console.log("Accumulator exists:", !!accumulator);
    if (accumulator) {
      console.log("Activity ID:", accumulator.activityId);
      console.log("Activity Title:", accumulator.activityTitle);
      console.log("Total Questions:", accumulator.totalQuestions);
      console.log("Answered Questions:", accumulator.answeredQuestions);
      console.log("Is Complete:", activityStore.isActivityComplete());
      console.log("Questions Feedback:", accumulator.questionsFeedback.map(f => ({
        questionId: f.questionId,
        score: f.score,
        decision: f.decision,
        timestamp: new Date(f.timestamp).toISOString()
      })));
    }
    console.log("=== END DEBUG ===");
  }

  function handleUserInput() {
    // Guard: solo permitir input en estado ASK
    if (!canPerformAction("send message", [BotState.ASK])) {
      return;
    }

    const input = document.querySelector(
      ".text-input-container textarea"
    ) as HTMLTextAreaElement;
    if (input) {
      const userMessage = input.value.trim();
      if (userMessage) {
        addMessage("user", userMessage);
        input.value = "";
        processUserInput(userMessage);
      }
    }
  }

  function handleClearInput() {
    const input = document.querySelector(
      ".text-input-container textarea"
    ) as HTMLTextAreaElement;
    if (input) {
      input.value = "";
    }
  }

  async function processUserInput(message: string) {
    console.log(
      `Processing user input: ${message}, current state: ${stateMachine.currentState}`
    );
    if (stateMachine.currentState === BotState.ASK) {
      stateMachine.transition(BotState.LISTEN_INPUT);
      stateMachine.transition(BotState.EVALUATE);
      audioService.playLoop('thinking');
      updateUI();
      stateMachine.transition(BotState.FEEDBACK);

      // IMPORTANTE: Esperar un tick para asegurar que el mensaje del usuario se renderice
      await new Promise((resolve) => setTimeout(resolve, 10));
      await new Promise((resolve) => setTimeout(resolve, 800));

      // Agregar mensaje de espera DESPU√âS del mensaje del usuario
      const waitingMessage: Message = {
        id: `waiting-${Date.now()}`, // ID √∫nico con prefijo
        type: "waiting",
        content: "Assistant is thinking",
        timestamp: new Date(),
      };
      chatStore.addMessage(waitingMessage);
      waitingMessageId = waitingMessage.id;
      renderMessages();

      // Iniciar animaci√≥n solo en el mensaje de espera
      let dots = 0;
      const animationInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        const dotsText = ".".repeat(dots);
        const messageEl = document.querySelector(
          `[data-message-id="${waitingMessageId}"] .content`
        );
        if (messageEl) {
          messageEl.textContent = "Assistant is thinking" + dotsText;
        }
      }, 500);

      try {
        // Calculate time spent
        const timeSpent = questionStartTime
          ? Math.floor((Date.now() - questionStartTime) / 1000)
          : 0;

        // Build activity payload
        const currentQuestion = activityStore.getCurrentQuestion();
        const activityPayload = {
          ACTIVITY_TITLE: activityStore.currentActivity?.title || "",
          ACTIVITY_LEVEL: activityStore.currentActivity?.level || "",
          ACTIVITY_CONTEXT:
            activityStore.currentActivity?.activityContext || "",
          ACTIVITY_DESCRIPTION:
            activityStore.currentActivity?.description || "",
          QUESTION_ID: currentQuestion?.id || "",
          QUESTION_TEXT: currentQuestion?.question || "",
          QUESTION_TYPE: currentQuestion?.type || "",
          EVALUATE_POINTS: currentQuestion?.evaluatePoints.join(", ") || "",
          HINT_TEXT: currentQuestion?.hint || "",
          USER_INPUT: message,
          HINT_USED: hintUsedForCurrentQuestion,
          TIME_SPENT: timeSpent,
        };

        // Get feedback from OpenAI
        const feedback = await openAIService.getFeedback(activityPayload);

        // Limpiar animaci√≥n y remover mensaje de espera
        clearInterval(animationInterval);
        audioService.stop('thinking');
        chatStore.removeMessage(waitingMessageId!);
        waitingMessageId = null;
        renderMessages(); // IMPORTANTE: renderizar despu√©s de remover

        // Agregar feedback
        let feedbackContent = `<div class="feedback-section">${marked(feedback.feedback)}</div>`;
        if (feedback.corrections) {
          feedbackContent += `<hr><div class="corrections-section"><strong>Corrections:</strong><br>${marked(feedback.corrections)}</div>`;
        }
        if (feedback.tips) {
          feedbackContent += `<hr><div class="tips-section"><strong>Tips:</strong><br>${marked(feedback.tips)}</div>`;
        }
        addMessage("feedback", feedbackContent);

        // Accumulate feedback data
        const feedbackData: QuestionFeedbackData = {
          questionId: currentQuestion?.id || "",
          questionText: currentQuestion?.question || "",
          userAnswer: message,
          score: feedback.score || 0,
          decision: feedback.decision || "",
          criteria: feedback.criteria || {
            semanticRelevance: 0,
            grammaticalCorrectness: 0,
            vocabularyAppropriate: 0,
            pronunciation: 0,
          },
          feedback: feedback.feedback || "",
          corrections: feedback.corrections || null,
          tips: feedback.tips || "",
          hintUsed: hintUsedForCurrentQuestion,
          timestamp: Date.now(),
        };
        activityStore.addQuestionFeedback(feedbackData);

        // Check if activity is complete
        if (activityStore.isActivityComplete()) {
          console.log("Activity is now complete!");
        }

        stateMachine.transition(BotState.NEXT_PROMPT);

        // Marcar pregunta como respondida
        const questionForMarking = activityStore.getCurrentQuestion();
        if (questionForMarking) {
          activityStore.markQuestionAsAnswered(questionForMarking.id);
          console.log(`Question ${questionForMarking.id} marked as answered`);
        }

        // Guardar estado en localStorage
        saveCurrentQuestionState();

        // Transicionar a FEEDBACK pero NO avanzar
        stateMachine.transition(BotState.FEEDBACK);

        // Actualizar UI para habilitar NEXT
        updateUI();

        console.log("Feedback complete. User must click NEXT to continue.");
      } catch (error) {
        console.error("Error getting feedback:", error);
        clearInterval(animationInterval);
        audioService.stop('thinking');
        chatStore.removeMessage(waitingMessageId!);
        waitingMessageId = null;
        renderMessages(); // IMPORTANTE: renderizar despu√©s de remover

        // Agregar mensaje de error
        const errorMessage = addMessage(
          "error",
          "Connection error! Please check your internet and try again."
        );

        // Auto-dismiss error message after 4 seconds
        setTimeout(() => {
          chatStore.removeMessage(errorMessage.id);
          renderMessages();
          updateUI(); // Re-enable controls after error message is dismissed
        }, 4000);

        // Return to waiting state (follow proper state flow)
        stateMachine.transition(BotState.NEXT_PROMPT);
        stateMachine.transition(BotState.ASK);
        hintUsedForCurrentQuestion = false; // Reset hint usage for retry
        updateUI();
      }
    }
  }

  function saveCurrentQuestionState() {
    const currentQuestion = activityStore.getCurrentQuestion();
    if (!currentQuestion) {
      console.warn("Cannot save: no current question");
      return;
    }

    // Obtener todos los mensajes de la pregunta actual
    const messages = chatStore.getMessages();

    // Extraer respuesta del usuario (√∫ltimo mensaje de tipo 'user')
    const userMessage = messages
      .slice()
      .reverse()
      .find((msg) => msg.type === "user");
    const userResponse = userMessage ? userMessage.content : "";

    // Extraer feedback (√∫ltimo mensaje de tipo 'feedback')
    const feedbackMessage = messages
      .slice()
      .reverse()
      .find((msg) => msg.type === "feedback");
    const feedback = feedbackMessage ? feedbackMessage.content : "";

    const questionData = {
      questionId: currentQuestion.id,
      userResponse,
      feedback,
      hintUsed: hintUsedForCurrentQuestion,
      timestamp: Date.now(),
      completed: !!feedback, // Si hay feedback, est√° completada
    };

    chatStore.saveQuestionToStorage(currentQuestion.id, questionData);
    console.log(
      `Saved state for question ${currentQuestion.id}:`,
      questionData
    );
  }

  function loadQuestionState(questionId: string) {
    try {
      console.log(`Loading state for question: ${questionId}`);

      const savedData = chatStore.loadQuestionFromStorage(questionId);

      if (savedData) {
        // Validar integridad de datos
        if (
          typeof savedData.questionId !== "string" ||
          savedData.questionId !== questionId
        ) {
          throw new Error("Data corruption: questionId mismatch");
        }

        console.log(`Found saved data:`, savedData);

        hintUsedForCurrentQuestion = savedData.hintUsed;
        clearCurrentChat();

        const question = activityStore.getCurrentQuestion();
        if (question) {
          addMessage("assistant", question.question);
        }

        if (savedData.userResponse) {
          addMessage("user", savedData.userResponse);
        }

        if (savedData.feedback) {
          addMessage("feedback", savedData.feedback);
        }

        console.log(`Restored question state for ${questionId}`);
      } else {
        console.log(
          `No saved data for question ${questionId}, showing fresh question`
        );
        clearCurrentChat();
        askQuestion();
      }
    } catch (error) {
      console.error("Error loading question state:", error);
      // Fallback: mostrar pregunta fresca
      clearCurrentChat();
      askQuestion();
    }
  }

  function clearCurrentChat() {
    console.log("Clearing current chat display");
    chatStore.clearMessages(); // Esto limpia solo la pregunta actual
    renderMessages(); // Actualizar la vista
  }

  function handleBackNavigation() {
    try {
      console.log("handleBackNavigation called");

      // Guard: solo permitir navegaci√≥n en ASK o FEEDBACK
      if (
        !canPerformAction("navigate back", [BotState.ASK, BotState.FEEDBACK])
      ) {
        return;
      }

      // Guard: no permitir si estamos en la primera pregunta
      if (activityStore.currentQuestionIndex === 0) {
        console.warn("‚ö†Ô∏è Already at first question");
        return;
      }

      // Guardar estado actual antes de navegar
      saveCurrentQuestionState();

      // Retroceder √≠ndice
      activityStore.currentQuestionIndex--;
      console.log(
        `Navigated back to question index: ${activityStore.currentQuestionIndex}`
      );

      // Establecer pregunta actual en ChatStore
      const question = activityStore.getCurrentQuestion();
      if (question) {
        chatStore.setCurrentQuestion(question.id);
      }

      // Cargar estado de la pregunta anterior
      if (question) {
        loadQuestionState(question.id);
      }

      // Actualizar state machine: establecer estado correcto seg√∫n si est√° respondida
      const isAnswered = question
        ? activityStore.isQuestionAnswered(question.id)
        : false;
      stateMachine.currentState = isAnswered ? BotState.FEEDBACK : BotState.ASK;
      console.log(
        `State set to: ${stateMachine.currentState} (answered: ${isAnswered})`
      );

      // Actualizar UI
      updateUI();
    } catch (error) {
      console.error("Error in handleBackNavigation:", error);
      // Intentar recuperar estado consistente
      updateUI();
    }
  }

  function handleNextNavigation() {
    try {
      console.log("handleNextNavigation called");

      // Guard: solo permitir navegaci√≥n en FEEDBACK
      if (!canPerformAction("navigate next", [BotState.FEEDBACK])) {
        return;
      }

      const currentQuestion = activityStore.getCurrentQuestion();

      // Guard: verificar que la pregunta est√© respondida
      if (
        !currentQuestion ||
        !activityStore.isQuestionAnswered(currentQuestion.id)
      ) {
        console.warn("‚ö†Ô∏è Cannot go next: current question not answered");
        return;
      }

      // Guardar estado actual
      saveCurrentQuestionState();

      // Avanzar √≠ndice
      if (activityStore.nextQuestion()) {
        console.log(
          `Navigated to question index: ${activityStore.currentQuestionIndex}`
        );

        const nextQuestion = activityStore.getCurrentQuestion();
        if (nextQuestion) {
          // Establecer pregunta actual en ChatStore
          chatStore.setCurrentQuestion(nextQuestion.id);

          // Verificar si la siguiente pregunta ya est√° respondida
          const isNextQuestionAnswered = activityStore.isQuestionAnswered(
            nextQuestion.id
          );

          // Cargar estado (si existe) o mostrar pregunta nueva
          loadQuestionState(nextQuestion.id);

          // Actualizar state machine seg√∫n si est√° respondida o no
          if (isNextQuestionAnswered) {
            // Si ya est√° respondida, ir directo a FEEDBACK
            stateMachine.currentState = BotState.FEEDBACK;
            console.log(
              `Next question already answered, state set to FEEDBACK`
            );
          } else {
            // Si es nueva, seguir flujo normal
            stateMachine.transition(BotState.NEXT_PROMPT);
            stateMachine.transition(BotState.ASK);
            console.log(`New question, state set to ASK`);
          }
        }
      } else {
        // No hay m√°s preguntas, terminar lecci√≥n
        console.log("No more questions, ending lesson");
        lessonEnded = true;
        stateMachine.transition(BotState.SUMMARY);
      }

      // Actualizar UI
      updateUI();
    } catch (error) {
      console.error("Error in handleNextNavigation:", error);
      // Intentar recuperar estado consistente
      updateUI();
    }
  }

  function handleTryAgain() {
    console.log("Try Again clicked");

    // Play click sound
    audioService.play("click");

    if (!canPerformAction("try again", [BotState.ASK, BotState.FEEDBACK])) {
      return;
    }

    const currentQuestion = activityStore.getCurrentQuestion();
    if (!currentQuestion) {
      console.warn("No current question to retry");
      return;
    }

    console.log(`Retrying question: ${currentQuestion.id}`);

    // 1. Resetear flags
    hintUsedForCurrentQuestion = false;
    activityStore.resetCurrentQuestion();
    questionStartTime = Date.now();

    // 2. Limpiar solo respuesta, feedback y hint (mantener la pregunta)
    const messages = chatStore.getMessages();
    const questionMessage = messages.find(
      (msg) =>
        msg.type === "assistant" && msg.content === currentQuestion.question
    );

    // Limpiar todos los mensajes
    chatStore.clearMessages();

    // Restaurar solo el mensaje de la pregunta
    if (questionMessage) {
      chatStore.addMessage(questionMessage);
    } else {
      // Si no encontramos el mensaje original, crear uno nuevo
      addMessage("assistant", currentQuestion.question);
    }

    renderMessages();

    // 3. Volver a ASK
    stateMachine.currentState = BotState.ASK;

    // 4. Actualizar UI
    updateUI();

    console.log("Question reset for retry. Chat cleared except question.");
  }

  // Export debug function to window for debugging
  (window as any).debugFeedbackAccumulator = debugFeedbackAccumulator;

  // Export activityStore to window for SummaryModal access
  (window as any).activityStore = activityStore;

  // Export stateMachine to window for global access
  (window as any).stateMachine = stateMachine;

  // Export general feedback service to window
  (window as any).openAIGeneralFeedbackService = openAIGeneralFeedbackService;
</script>

<style is:global>
  .bot-lesson {
    max-width: 600px;
    margin: 0 auto;
    padding: var(--spacing-md);
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
  }

  .chat-container {
    min-height: 60vh;
    overflow-y: auto;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
  }

  .chat-messages {
    display: flex;
    flex-direction: column;
  }

  .iniciar-btn {
    position: absolute;
    top: 40%;
    left: 50%;
    border-radius: 100%;
    transform: translate(-50%, -50%);
    background-color: var(--primary-color, #007bff);
    aspect-ratio: 1 / 1 !important;
    color: white;
    border: none;
    padding: 1rem;
    cursor: pointer;
    align-self: flex-start;
    font-weight: bold;
  }

  .iniciar-btn:hover {
    background-color: #0056b3;
  }

  .message-bubble {
    margin: var(--spacing-sm) 0;
    display: flex;
  }

  .message-greeting {
    justify-content: flex-start;
  }

  .message-assistant {
    justify-content: flex-start;
  }

  .message-user {
    justify-content: flex-end;
  }

  .message-hint {
    justify-content: center;
  }

  .message-feedback {
    justify-content: flex-start;
  }

  .content {
    max-width: 70%;
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--border-radius);
    font-family: var(--font-family);
    font-size: var(--font-size-base);
    word-wrap: break-word;
  }

  .message-greeting .content {
    background-color: #7cec87;
    color: var(--dark-color);
    font-weight: bold;
    animation: slideInLeft 0.6s ease-out;
  }

  .message-assistant .content {
    background-color: #e0e0e0;
    color: var(--dark-color);
    animation: slideInLeft 0.6s ease-out;
  }

  .message-user .content {
    background-color: var(--primary-color);
    color: white;
    animation: slideInUp 0.6s ease-out;
  }

  .message-hint .content {
    background-color: var(--warning-color);
    color: var(--dark-color);
    font-style: italic;
    animation: slideInUp 0.6s ease-out;
  }

  .message-feedback .content {
    background-color: #7cec87;
    color: var(--dark-color);
    animation: slideInLeft 0.6s ease-out;
  }

  .message-waiting {
    justify-content: flex-start;
  }

  .message-waiting .content {
      background-color: lightgray;
      color: var(--dark-color);
      font-style: italic;
      animation: slideInLeft 0.6s ease-out;
  }

  .message-error {
    justify-content: center;
  }

  .message-error .content {
      background-color: #ff4444;
      color: white;
      font-weight: bold;
      text-align: center;
      animation: slideInUp 0.6s ease-out;
  }

  /* Prevent re-animation on re-renders */
  .message-bubble.animated .content {
    animation: none !important;
  }

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-35px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>
